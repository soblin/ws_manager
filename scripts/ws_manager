#!/bin/bash

HELP_MSG="Usage:\n\
For checking current status, run\n\
ros2 run ws_manager ws_manager --check\n\n\
For clearing <ws_dir> from the current shell variables, run\n\
source <(ros2 run ws_manager ws_manager --clear <ws_path>)\n\n\
For cleaning up and re-initializing the shell variables with <ws_dir> as well as the system's ones(/opt/ros/~), run\n\
source <(ros2 run ws_manager ws_manager --reinit <ws_path>)\
"

SEPARATOR="========================================"

# (1) argparse
ARGPARSE=$(getopt -o '' --long check,help,clear:,reinit: -- "$@")
if [[ $? -ne 0 ]]; then
    exit 1;
fi
eval set -- "$ARGPARSE"
while [ : ]; do
    case "$1" in
        --check)
            cmd="check"
            path="None"
            break
            ;;
        --clear)
            cmd="clear"
            path=$2
            break
            ;;
        --reinit)
            cmd="reinit"
            path=$2
            break
            ;;
        --help)
            echo -e "${HELP_MSG}"
            exit
            ;;
        --)
            echo -e "${HELP_MSG}"
            exit
            ;;
    esac
done

# (2) check ENV_VAR existance
declare -a ENV_VARS_LIST=("COLCON_PREFIX_PATH" "AMENT_PREFIX_PATH" "CMAKE_PREFIX_PATH" "LD_LIBRARY_PATH" "PYTHONPATH" "GAZEBO_MODEL_PATH")
env_vars=()
for ENV_VAR in ${ENV_VARS_LIST[@]}; do
    if [[ "${ENV_VAR}" ]]; then
        env_vars=("${env_vars[@]}" ${ENV_VAR})
    fi
done

# (3) get non-empty env value
declare -A cur_env_values
for env_var in ${env_vars[@]}; do
    value=`printenv ${env_var}`
    if [[ "${value}" ]]; then
        # (.1) separate by ':' and store as lists
        IFS=':' read -r -a splits <<< "${value}"
        cur_env_values[${env_var}]=${splits[@]}
    fi
done

let max_item_num=5 # TODO
if [[ ${cmd} == "check" ]]; then
    echo "${SEPARATOR}"
    for env_var in "${!cur_env_values[@]}"; do
        values=(${cur_env_values[${env_var}]}) # NOTE: do (${var}), in order to interpret as array
        item_num=${#values[@]}
        cnt_num=${item_num}
        if [[ "${item_num}" -gt "${max_item_num}" ]]; then
            echo "${env_var}(${max_item_num} out of ${item_num} items):"
            cnt_num=${max_item_num}
        else
            echo "${env_var}:"
        fi
        let cnt_num=${cnt_num}-1 # NOTE: for seq indexing
        for i in `seq 0 ${cnt_num}`; do
            echo "${values[$i]}"
        done
        let cnt_num=${cnt_num}+1
        if [[ "${cnt_num}" != "${item_num}" ]]; then
            echo "......"
        fi
        echo "${SEPARATOR}"
    done
    exit
fi

# (4) get abs path to <ws_dir>
# (.1) if path[0] == "/" (abspath)
if [[ ${path:0:1} == "/" ]]; then
    ws_path=${path}
else
    cwd=$(pwd)
    ws_path="${cwd}/${path}"
fi
# (.2) regularize '..' in <ws_path>
ws_path=`realpath ${ws_path}`

# (5) do checking
# (.1) <ws_dir>/install is assumed to exist
install_path="${ws_path}/install"
if [ ! -d $install_path ]; then
    echo "echo \"Error: ${install_path} does not exist, exiting\""
    exit 1
fi

# (6) exclude entries that include <ws_dir> for overwriting
declare -A overwrite_env_values
for env_var in "${!cur_env_values[@]}"; do
    values=${cur_env_values[${env_var}]}
    # (.1) exclude item that contains <ws_path>
    overwrites=()
    for value in ${values[@]}; do
        if [[ "$value" != *"$ws_path"* ]]; then
            overwrites=("${overwrites[@]}" ${value})
        fi
    done
    overwrite_env_values[${env_var}]=${overwrites[@]}
done

# (7) convert [path1 path2 ...] to "path1:path2:..."
for env_var in "${!overwrite_env_values[@]}"; do
    lists=${overwrite_env_values[${env_var}]}
    lists_str=""
    i=0
    for list in ${lists[@]}; do
        if [[ $i == 0 ]]; then
            lists_str="${lists_str}${list}"
        else
            lists_str="${lists_str}:${list}"
        fi
        let i++
    done
    overwrite_env_values[${env_var}]=${lists_str}
done

if [[ ${cmd} == "clear" ]]; then
    # print the command to `source`
    command="echo \"Info: Clearing...\""
    i=0
    for env_var in "${!overwrite_env_values[@]}"; do
        command="${command} && export ${env_var}=\"${overwrite_env_values[${env_var}]}\""
        let i++;
    done
    command="${command} && echo \"Info: Done\""
    echo "${command}"
    exit
fi

if [[ ${cmd} == "reinit" ]]; then
    echo "echo 'reinit is WIP'"
    ## TODO
    ## for all paths in COLCON_PREFIX_PATH
    ## do clear => `command`
    ## and then => command+="source <ws_dir>/install/local_setup.bash"
    ## So `clear` function should be defined
    exit
fi
