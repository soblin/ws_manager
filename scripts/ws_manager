#!/bin/bash

HELP_MSG="Usage:\nFor checking current status, run\nros2 run ws_manager ws_manager --check\n\nFor updating shell variable, run\nsource <(ros2 run ws_manager ws_manager --{clear, reinit} <ws_path>)"
SEPARATOR="========================================"

# (1) argparse
ARGPARSE=$(getopt -o '' --long check,help,clear:,reinit: -- "$@")
if [[ $? -ne 0 ]]; then
    exit 1;
fi
eval set -- "$ARGPARSE"
while [ : ]; do
    case "$1" in
        --check)
            cmd="check"
            path="None"
            break
            ;;
        --clear)
            cmd="clear"
            path=$2
            break
            ;;
        --reinit)
            cmd="reinit"
            path=$2
            break
            ;;
        --help)
            echo -e "${HELP_MSG}"
            exit
            ;;
        --)
            echo -e "${HELP_MSG}"
            exit
            ;;
    esac
done

# (2) check ENV_VAR existance
declare -a ENV_VARS_LIST=("COLCON_PREFIX_PATH" "AMENT_PREFIX_PATH" "CMAKE_PREFIX_PATH" "LD_LIBRARY_PATH" "PYTHONPATH" "GAZEBO_MODEL_PATH")
env_vars=()
for ENV_VAR in ${ENV_VARS_LIST[@]}; do
    if [[ "${ENV_VAR}" ]]; then
        env_vars=("${env_vars[@]}" ${ENV_VAR})
    fi
done

# (3) get non-empty env value
declare -A cur_env_values
for env_var in ${env_vars[@]}; do
    value=`printenv ${env_var}`
    if [[ "${value}" ]]; then
        # (.1) separate by ':' and store as lists
        IFS=':' read -r -a splits <<< "${value}"
        cur_env_values[${env_var}]=${splits[@]}
    fi
done

let max_item_num=5
if [[ ${cmd} == "check" ]]; then
    echo "${SEPARATOR}"
    for env_var in "${!cur_env_values[@]}"; do
        values=(${cur_env_values[${env_var}]}) # NOTE: do (${var}), in order to interpret as array
        item_num=${#values[@]}
        if [[ "${item_num}" -gt "${max_item_num}" ]]; then
            item_num=${max_item_num}
            echo "${env_var} (up to ${item_num} items):"
        else
            echo "${env_var}:"
        fi
        let item_num=${item_num}-1 # NOTE: for seq indexing
        for i in `seq 0 ${item_num}`; do
            echo "${values[$i]}"
        done
        echo "${SEPARATOR}"
    done
    exit
fi

# (4) get abs path to <ws_dir>
# (.1) if path[0] == "/" (abspath)
if [[ ${path:0:1} == "/" ]]; then
    ws_path=${path}
else
    cwd=$(pwd)
    ws_path="${cwd}/${path}"
fi
# (.2) regularize '..' in <ws_path>
ws_path=`realpath ${ws_path}`

# (5) do checking
# (.1) <ws_dir>/install is assumed to exist
install_path="${ws_path}/install"
if [ ! -d $install_path ]; then
    exit 1
fi

# (6) delete entries that include <ws_dir>
declare -A overwrite_env_values
for env_var in "${!cur_env_values[@]}"; do
    values=${cur_env_values[${env_var}]}
    # (.1) exclude item that contains <ws_path>
    overwrites=()
 for split in ${values[@]}; do
        if [[ "$split" != *"$ws_path"* ]]; then
            overwrites=("${overwrites[@]}" ${split})
        fi
    done
    overwrite_env_values[${env_var}]=${overwrites[@]}
done

# (7) convert [path1 path2 ...] to "path1:path2:..."
for env_var in "${!overwrite_env_values[@]}"; do
    lists=${overwrite_env_values[${env_var}]}
    lists_str=""
    i=0
    for list in ${lists[@]}; do
        if [[ $i == 0 ]]; then
            lists_str="${lists_str}${list}"
        else
            lists_str="${lists_str}:${list}"
        fi
        let i++
    done
    overwrite_env_values[${env_var}]=${lists_str}
done

if [[ ${cmd} == "clear" ]]; then
    # print the command to `source`
    command=""
    i=0
    for env_var in "${!overwrite_env_values[@]}"; do
        if [[ $i == 0 ]]; then
            command="export ${env_var}=\"${overwrite_env_values[${env_var}]}\""
        else
            command="${command} && export ${env_var}=\"${overwrite_env_values[${env_var}]}\""
        fi
        let i++;
    done
    echo "${command}"
    exit
fi

if [[ ${cmd} == "reinit" ]]; then
    echo "echo 'reinit is WIP'"
    exit
fi
