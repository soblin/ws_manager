#!/bin/bash

HELP_MSG="Usage:\n\
For checking current status, run\n\
ros2 run ws_manager ws_manager --check\n\n\
For clearing <ws_dir> from the current shell variables, run\n\
source <(ros2 run ws_manager ws_manager --clear <ws_path>)\n\n\
For cleaning up and re-initializing the shell variables with <ws_dir> as well as the system's ones(/opt/ros/~), run\n\
source <(ros2 run ws_manager ws_manager --reinit <ws_path>)\
"

SEPARATOR="========================================"

ECHO_INFO() {
    local -n _body=$1
    if [[ "${_body}" == "" ]]; then
        _body="echo \"[INFO]: $2\""
    else
        _body="${_body};echo \"[INFO]: $2\""
    fi
}

ECHO_WARN() {
    local -n _body=$1
    if [[ "${_body}" == "" ]]; then
        _body="echo \"[WARN]: $2\""
    else
        _body="${_body};echo \"[WARN]: $2\""
    fi
}

ECHO_ERROR() {
    local -n _body=$1
    if [[ "${_body}" == "" ]]; then
        _body="echo \"[WARN]: $2\""
    else
        _body="${_body};echo \"[ERROR]: $2\""
    fi
}

ECHO_CMD() {
    local -n _body=$1
    if [[ "${_body}" == "" ]]; then
        _body="$2"
    else
        _body="${_body};$2"
    fi
}

# (1) argparse
ARGPARSE=$(getopt -o '' --long check,help,clear:,reinit: -- "$@")
if [[ $? -ne 0 ]]; then
    exit 1;
fi
eval set -- "$ARGPARSE"
while [ : ]; do
    case "$1" in
        --check)
            cmd="check"
            path="None"
            break
            ;;
        --clear)
            cmd="clear"
            path=$2
            break
            ;;
        --reinit)
            cmd="reinit"
            path=$2
            break
            ;;
        --help)
            echo -e "${HELP_MSG}"
            exit
            ;;
        --)
            echo -e "${HELP_MSG}"
            exit
            ;;
    esac
done

# (2) check ENV_VAR existance
declare -a ENV_VARS_LIST=("COLCON_PREFIX_PATH" "AMENT_PREFIX_PATH" "CMAKE_PREFIX_PATH" "LD_LIBRARY_PATH" "PYTHONPATH" "GAZEBO_MODEL_PATH")
env_vars=()
for ENV_VAR in ${ENV_VARS_LIST[@]}; do
    if [[ "${ENV_VAR}" ]]; then
        env_vars=("${env_vars[@]}" ${ENV_VAR})
    fi
done

# (3) get non-empty env value
declare -A map_var_values
for env_var in ${env_vars[@]}; do
    value=`printenv ${env_var}`
    if [[ "${value}" ]]; then
        # (.1) separate by ':' and store as lists
        IFS=':' read -r -a splits <<< "${value}"
        map_var_values[${env_var}]=${splits[@]}
    fi
done

let max_item_num=5 # TODO
if [[ ${cmd} == "check" ]]; then
    echo "${SEPARATOR}"
    for env_var in "${!map_var_values[@]}"; do
        values=(${map_var_values[${env_var}]}) # NOTE: do (${var}), in order to interpret as array
        item_num=${#values[@]}
        cnt_num=${item_num}
        if [[ "${item_num}" -gt "${max_item_num}" ]]; then
            echo "${env_var}(${max_item_num} out of ${item_num} items):"
            cnt_num=${max_item_num}
        else
            echo "${env_var}:"
        fi
        let cnt_num=${cnt_num}-1 # NOTE: for seq indexing
        for i in `seq 0 ${cnt_num}`; do
            echo "${values[$i]}"
        done
        let cnt_num=${cnt_num}+1
        if [[ "${cnt_num}" != "${item_num}" ]]; then
            echo "......"
        fi
        echo "${SEPARATOR}"
    done
    exit
fi

# (4) get abs path to <ws_dir>
# (.1) if path[0] == "/" (abspath)
if [[ ${path:0:1} == "/" ]]; then
    ws_path=${path}
else
    cwd=$(pwd)
    ws_path="${cwd}/${path}"
fi
# (.2) regularize '..' in <ws_path>
ws_path=`realpath ${ws_path}`

# (5) do checking
# (.1) <ws_dir>/install is assumed to exist
install_path="${ws_path}/install"
if [ ! -d $install_path ]; then
    body=""
    msg="${install_path} does not exists, exiting."
    ECHO_ERROR body msg
    echo "${body}"
    exit 1
fi

# (6) exclude entries that include <ws_dir> for overwriting
clear_env_values() {
    # usage: clear_env_values ws_path map_var_values map_env_newvalues
    local -n _ws_path=$1
    local -n _map_var_values=$2
    local -n _map_env_newvalues=$3
    for env_var in "${!_map_var_values[@]}"; do
        values=${_map_var_values[${env_var}]}
        # (.1) exclude item that contains <ws_path>
        _cleareds=()
        for value in ${values[@]}; do
            if [[ "$value" != *"$_ws_path"* ]]; then
                _cleareds=("${_cleareds[@]}" ${value})
            fi
        done
        _map_env_newvalues[${env_var}]=${_cleareds[@]}
    done
}

declare -A map_env_newvalues
clear_env_values ws_path map_var_values map_env_newvalues

# (7) convert [path1 path2 ...] to "path1:path2:..."
for env_var in "${!map_env_newvalues[@]}"; do
    values=${map_env_newvalues[${env_var}]}
    values_str=""
    i=0
    for value in ${values[@]}; do
        if [[ $i == 0 ]]; then
            values_str="${values_str}${value}"
        else
            values_str="${values_str}:${value}"
        fi
        let i++
    done
    map_env_newvalues[${env_var}]=${values_str}
done

if [[ ${cmd} == "clear" ]]; then
    # print the command to `source`
    body=""
    ECHO_INFO body "Clearing..."
    i=0
    for env_var in "${!map_env_newvalues[@]}"; do
        cmd="export ${env_var}=\"${map_env_newvalues[${env_var}]}\""
        ECHO_CMD body "${cmd}"
        let i++;
    done
    ECHO_INFO body "Done."
    echo "${body}"
    exit
fi

if [[ ${cmd} == "reinit" ]]; then
    echo "echo 'reinit is WIP'"
    ## TODO
    ## for all paths in COLCON_PREFIX_PATH
    ## do clear => `command`
    ## and then => command+="source <ws_dir>/install/local_setup.bash"
    ## So `clear` function should be defined
    exit
fi
